"use strict";(self.webpackChunkbetalectic_website=self.webpackChunkbetalectic_website||[]).push([["7983"],{7544:function(e,n,r){r.r(n),r.d(n,{assets:function(){return a},contentTitle:function(){return c},default:function(){return h},frontMatter:function(){return i},metadata:function(){return s},toc:function(){return l}});var s=r(6722),t=r(5893),o=r(65);let i={slug:"concurrency-in-nodejs",title:"Scaling Node.js Concurrency with the Cluster Module",authors:["avir"],image:"/img/blogs/concurrency.jpg"},c="Scaling Node.js Concurrency with the Cluster Module",a={authorsImageUrls:[void 0]},l=[{value:"What is the Cluster Module ?",id:"what-is-the-cluster-module-",level:2},{value:"Why use clustering?",id:"why-use-clustering",level:3},{value:"Understanding Node.js Scaling with the Kitchen Analogy",id:"understanding-nodejs-scaling-with-the-kitchen-analogy",level:3},{value:"Practical Example with Code",id:"practical-example-with-code",level:2},{value:"Pseudo Code",id:"pseudo-code",level:2},{value:"Results",id:"results",level:2},{value:"\uD83D\uDCDD Java vs Node.js Cluster Module - Quick Reference",id:"-java-vs-nodejs-cluster-module---quick-reference",level:2}];function d(e){let n={code:"code",em:"em",h2:"h2",h3:"h3",hr:"hr",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.p,{children:["Node.js is often described as ",(0,t.jsx)(n.strong,{children:"single-threaded"}),", but it powers some of the world\u2019s highest-traffic applications. So how does it manage to handle ",(0,t.jsx)(n.strong,{children:"thousands of concurrent connections"}),", ",(0,t.jsx)(n.strong,{children:"network I/O"}),",  and ",(0,t.jsx)(n.strong,{children:"file reads/writes"}),"\u2014with just one thread?"]}),"\n",(0,t.jsxs)(n.p,{children:["The short answer: ",(0,t.jsx)(n.strong,{children:"It doesn\u2019t."})]}),"\n",(0,t.jsxs)(n.p,{children:["Node.js uses a ",(0,t.jsx)(n.strong,{children:"single thread for executing JavaScript"}),", but it\u2019s backed by a ",(0,t.jsx)(n.strong,{children:"multi-threaded architecture under the hood"})," using:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["The ",(0,t.jsx)(n.strong,{children:"libuv thread pool"})," (4 threads by default)"]}),"\n",(0,t.jsxs)(n.li,{children:["The ",(0,t.jsx)(n.strong,{children:"cluster module"})," (multi-process architecture)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Worker threads"})," (for CPU-bound tasks)"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["In this post, we\u2019ll dive into how Node.js achieves real-world scalability using the ",(0,t.jsx)(n.code,{children:"cluster"})," module\u2014comparing this process-based approach with Java\u2019s traditional multithreading model"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"what-is-the-cluster-module-",children:"What is the Cluster Module ?"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"cluster"})," module allows you to ",(0,t.jsx)(n.strong,{children:"create multiple copies (workers)"})," of your Node.js application. These workers are separate ",(0,t.jsx)(n.strong,{children:"processes"}),", not threads. These are forked from a single ",(0,t.jsx)(n.strong,{children:"master process"}),", and they can be scheduled by the OS to run on ",(0,t.jsx)(n.strong,{children:"different CPU cores"}),", giving you ",(0,t.jsx)(n.strong,{children:"true parallelism"})," \u2014 not just concurrency. The workers have these similarity among them:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Run the ",(0,t.jsx)(n.strong,{children:"same code"})]}),"\n",(0,t.jsxs)(n.li,{children:["Share the same ",(0,t.jsx)(n.strong,{children:"server port"})]}),"\n",(0,t.jsxs)(n.li,{children:["Can handle requests ",(0,t.jsx)(n.strong,{children:"independently and in parallel"})]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["So even though each process is still single-threaded internally, together they give the illusion of ",(0,t.jsx)(n.strong,{children:"multithreaded execution"}),"\u2014because multiple requests can be handled ",(0,t.jsx)(n.strong,{children:"at the same time"})," by different processes."]}),"\n",(0,t.jsx)(n.h3,{id:"why-use-clustering",children:"Why use clustering?"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["To ",(0,t.jsx)(n.strong,{children:"utilize all CPU cores"})," on the machine (default Node.js uses only one)"]}),"\n",(0,t.jsxs)(n.li,{children:["To handle ",(0,t.jsx)(n.strong,{children:"more concurrent requests"})," without blocking"]}),"\n",(0,t.jsxs)(n.li,{children:["To build ",(0,t.jsx)(n.strong,{children:"scalable"})," and ",(0,t.jsx)(n.strong,{children:"high-performance"})," applications"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"understanding-nodejs-scaling-with-the-kitchen-analogy",children:"Understanding Node.js Scaling with the Kitchen Analogy"}),"\n",(0,t.jsxs)(n.p,{children:["Imagine your restaurant has ",(0,t.jsx)(n.strong,{children:"8 kitchens."})]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["At first, you have ",(0,t.jsx)(n.strong,{children:"only 1 chef"})," working in ",(0,t.jsx)(n.strong,{children:"just one kitchen"}),". That chef can only cook one order at a time, so the other 7 kitchens sit empty and unused."]}),"\n",(0,t.jsxs)(n.li,{children:["Now, you hire ",(0,t.jsx)(n.strong,{children:"7 more chefs"}),", so you have ",(0,t.jsx)(n.strong,{children:"8 chefs working in 8 separate kitchens"}),".\nEach chef can cook orders independently, so you can serve ",(0,t.jsx)(n.strong,{children:"8 customers at the same time"})," \u2014 fully using all your kitchens."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Here in this analogy, kitchen refers to the CPU cores and the chefs are the processes to handle different operations."}),"\n",(0,t.jsxs)(n.p,{children:["Note:- When you use the ",(0,t.jsxs)(n.strong,{children:[(0,t.jsx)(n.code,{children:"cluster"})," module"]})," in Node.js, you're not creating ",(0,t.jsx)(n.em,{children:"threads"})," like you might in Java or C++. Instead, you're creating multiple ",(0,t.jsx)(n.strong,{children:"independent processes."})]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"practical-example-with-code",children:"Practical Example with Code"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-jsx",children:'const cluster = require("cluster");\nconst os = require("os");\nconst knexConfig = //DB_Connections\nconst knex = require("knex")(knexConfig);\nconst numCPUs = os.cpus().length;\n\nconst mode =\n  process.argv.find((arg) => arg.startsWith("--mode="))?.split("=")[1] ||\n  "cluster";\n\nasync function processPropertiesSequentially(properties) {\n  const workerKnex = require("knex")(knexConfig);\n\n  for (const property of properties) {\n    await workerKnex("properties").where("uuid", property.uuid).update({\n      property_date_type: "date-given",\n    });\n  }\n\n  await workerKnex.destroy();\n}\n\nif (mode === "single") {\n  console.log("Running in SINGLE-threaded mode");\n  console.time("Single-threaded duration");\n\n  knex("properties")\n    .select("uuid", "property_date_type")\n    .where("property_date_type", "dated")\n    .then(async (properties) => {\n      await processPropertiesSequentially(properties);\n      console.timeEnd("Single-threaded duration");\n      await knex.destroy();\n      process.exit(0);\n    })\n    .catch(async (err) => {\n      console.error("Error fetching properties:", err);\n      await knex.destroy();\n      process.exit(1);\n    });\n} else if (mode === "cluster") {\n  if (cluster.isMaster) {\n    console.log("Running in CLUSTER mode");\n    console.log(`Master ${process.pid} is running`);\n    console.time("Cluster duration");\n\n    knex("properties")\n      .select("uuid", "property_date_type")\n      .where("property_date_type", "dated")\n      .then((properties) => {\n        const plainProperties = JSON.parse(JSON.stringify(properties));\n        const chunkSize = Math.ceil(plainProperties.length / numCPUs);\n        let exitedWorkers = 0;\n\n        for (let i = 0; i < numCPUs; i++) {\n          const start = i * chunkSize;\n          const end = start + chunkSize;\n          const propertyChunk = plainProperties.slice(start, end);\n\n          const worker = cluster.fork();\n          worker.send(propertyChunk);\n\n          worker.on("message", (msg) => {\n            console.log(`Worker ${worker.process.pid}: ${msg}`);\n          });\n\n          worker.on("exit", async (code) => {\n            exitedWorkers++;\n            if (exitedWorkers === numCPUs) {\n              console.timeEnd("Cluster duration");\n              await knex.destroy();\n              process.exit(0);\n            }\n          });\n        }\n      })\n      .catch(async (err) => {\n        console.error("Error fetching properties:", err);\n        await knex.destroy();\n        process.exit(1);\n      });\n  } else {\n    process.on("message", async (propertyChunk) => {\n      const workerKnex = require("knex")(knexConfig);\n      try {\n        for (const property of propertyChunk) {\n          await workerKnex("properties").where("uuid", property.uuid).update({\n            property_date_type: "date-given",\n          });\n        }\n      } catch (err) {\n        process.send(`Error: ${err.message}`);\n      } finally {\n        await workerKnex.destroy();\n        process.exit(0);\n      }\n    });\n  }\n} else {\n  console.error(`Unknown mode: ${mode}`);\n  process.exit(1);\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"pseudo-code",children:"Pseudo Code"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-jsx",children:'1. Initialize database connections and detect the number of available CPU    cores.\n\n2. Check if the current process is the "master":\n   - Yes (Master Process):\n     a. Fetch all properties from the database where `property_date_type` is         "dated".\n     b. Split the list of properties into equal chunks based on number of            CPU cores.\n     c. For each chunk:\n        i. Fork a new worker process.\n        ii. Send the chunk of properties to that worker.\n\n     d. Listen for messages or completion signals from workers.\n     e. When all workers have completed:\n        - Log total time taken.\n        - Close the database connection.\n\n   - No (Worker Process):\n     a. Receive a chunk of properties from the master.\n     b. For each property in the chunk:\n        - Update its `property_date_type` from "dated" to "date-given" in              the database.\n     c. After finishing:\n        - Close the database connection.\n        - Exit the worker process.\n\n'})}),"\n",(0,t.jsx)(n.h2,{id:"results",children:"Results"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"When the dataset is not large enough, the single-threaded approach can be faster, and the multi-threaded (cluster) approach may become an overkill. In this case, the dataset contains only 1,000 properties."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"Screenshot 2025-05-18 at 10.12.12\u202FPM.png",src:r(5229).Z+"",width:"2258",height:"326"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"As the dataset size increases, the cluster-based approach starts performing better\u2014taking nearly half the time compared to the single-threaded approach. In this case, the dataset consists of 62,000 properties."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"Screenshot 2025-05-18 at 10.04.04\u202FPM.png",src:r(8799).Z+"",width:"2248",height:"310"})}),"\n",(0,t.jsx)(n.h2,{id:"-java-vs-nodejs-cluster-module---quick-reference",children:"\uD83D\uDCDD Java vs Node.js Cluster Module - Quick Reference"}),"\n",(0,t.jsx)(n.p,{children:"Just for context, here are a few quick differences between Java and Node.js threads:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\uD83E\uDDE9 Node.js ",(0,t.jsx)(n.code,{children:"cluster"})," creates ",(0,t.jsx)(n.strong,{children:"multiple processes"}),", while Java typically uses ",(0,t.jsx)(n.strong,{children:"multiple threads"})," within one process."]}),"\n",(0,t.jsxs)(n.li,{children:["\uD83E\uDDE0 Java threads ",(0,t.jsx)(n.strong,{children:"share memory"}),", whereas Node.js cluster workers ",(0,t.jsx)(n.strong,{children:"do not"})," \u2014 they communicate via ",(0,t.jsx)(n.strong,{children:"IPC (message passing)"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["\u2699\uFE0F Java gives ",(0,t.jsx)(n.strong,{children:"fine-grained control"})," over threading (e.g., ",(0,t.jsx)(n.code,{children:"start()"}),", ",(0,t.jsx)(n.code,{children:"join()"}),"), while Node.js ",(0,t.jsx)(n.code,{children:"cluster"})," manages workers more like ",(0,t.jsx)(n.strong,{children:"isolated services"}),"."]}),"\n"]})]})}function h(e={}){let{wrapper:n}={...(0,o.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},5229:function(e,n,r){r.d(n,{Z:function(){return s}});let s=r.p+"assets/images/avi_result_1-73a5301985dfb86559feb215b06db65c.png"},8799:function(e,n,r){r.d(n,{Z:function(){return s}});let s=r.p+"assets/images/avi_result_2-19e1c63d3d5b085def9e591d0b249cc1.png"},65:function(e,n,r){r.d(n,{Z:function(){return c},a:function(){return i}});var s=r(7294);let t={},o=s.createContext(t);function i(e){let n=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),s.createElement(o.Provider,{value:n},e.children)}},6722:function(e){e.exports=JSON.parse('{"permalink":"/pr-preview/pr-43/blog/concurrency-in-nodejs","source":"@site/blog/2025-05-20-concurrency-in-nodejs.md","title":"Scaling Node.js Concurrency with the Cluster Module","description":"Node.js is often described as single-threaded, but it powers some of the world\u2019s highest-traffic applications. So how does it manage to handle thousands of concurrent connections, network I/O,  and file reads/writes\u2014with just one thread?","date":"2025-05-20T00:00:00.000Z","tags":[],"hasTruncateMarker":true,"authors":[{"name":"Avi Rajput","title":"Jr. Software Engineer","page":{"permalink":"/pr-preview/pr-43/blog/authors/avir"},"socials":{"x":"https://x.com/y2j_avi","linkedin":"https://www.linkedin.com/in/avi-rajput-a07a54221/"},"imageURL":"/pr-preview/pr-43/img/blogs/AuthorProfile/avi.jpg","key":"avir"}],"frontMatter":{"slug":"concurrency-in-nodejs","title":"Scaling Node.js Concurrency with the Cluster Module","authors":["avir"],"image":"/img/blogs/concurrency.jpg"},"unlisted":false,"prevItem":{"title":"Orchestrating Laravel Queues & Scheduling in Docker with Cron & Supervisor","permalink":"/pr-preview/pr-43/blog/orchestrating-laravel-queues"},"nextItem":{"title":"Validation Best Practices in Fintech Apps with React Hook Form and Yup","permalink":"/pr-preview/pr-43/blog/react-hook-form"}}')}}]);